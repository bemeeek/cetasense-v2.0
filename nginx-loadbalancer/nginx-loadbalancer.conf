# nginx-loadbalancer/nginx-loadbalancer.conf
# Simple configuration untuk Docker Compose Replicas

worker_processes auto;
error_log /var/log/nginx/error.log warn;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Log format with instance tracking
    log_format main '$remote_addr -> $upstream_addr [$time_local] "$request" '
                     '$status $body_bytes_sent rt=$request_time '
                     'instance="$upstream_http_x_instance_id"';
    access_log /var/log/nginx/access.log main;

    client_max_body_size 100M;  # Maksimal request body size

    # Basic optimizations
    sendfile on;
    keepalive_timeout 65;
    gzip on;
    gzip_types text/plain text/css application/javascript application/json;

    # Docker DNS resolver
    resolver 127.0.0.11 valid=10s ipv6=off;

    # ===== UPSTREAM DEFINITIONS =====
    # Docker Compose akan auto-resolve replicas
    upstream go_gateway_cluster {
        # Docker DNS otomatis load balance ke semua go_gateway replicas
        zone go_gateway_cluster 64k;
        server go_gateway:8081 resolve;
        keepalive 16;
    }

    upstream py_api_cluster {
        # Docker DNS otomatis load balance ke semua py_api replicas
        zone py_api_cluster 64k;
        server py_api:8000 resolve;
        keepalive 16;
    }

    upstream rabbit_consumer_cluster {
        # Docker DNS otomatis load balance ke semua rabbit_consumer replicas
        zone rabbit_consumer_cluster 64k;
        server rabbit_consumer:8001 resolve;
        keepalive 16;
    }

    upstream celery_worker_cluster {
        # Docker DNS otomatis load balance ke semua celery_worker replicas
        zone celery_worker_cluster 64k;
        server celery_worker:8002 resolve;
        keepalive 16;
    }

    upstream frontend_cluster {
        zone frontend_cluster 64k;
        server frontend:80 resolve;
        keepalive 16;
    }

    # ===== MAIN SERVER =====
    server {
        listen 80 default_server;
        server_name _;

        # API routes ke Go Gateway replicas
        location ^~ /api/ {
            proxy_pass http://go_gateway_cluster;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass_header X-Cache;
            
            # Debug header untuk tracking
            add_header X-Upstream-Addr $upstream_addr always;
            
            proxy_connect_timeout 5s;
            proxy_read_timeout 30s;
        }
        # Localization routes ke Python API replicas
        location ^~ /localize/ {
            proxy_pass http://py_api_cluster;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            add_header X-Upstream-Addr $upstream_addr always;
            
            proxy_connect_timeout 5s;
            proxy_read_timeout 60s;
        }

        # Frontend routes
        location / {
            proxy_pass http://frontend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # Health check
        location /health {
            return 200 "Load Balancer OK - CetaSense Replicas\n";
            add_header Content-Type text/plain;
        }

        # Nginx status
        location /nginx_status {
            stub_status on;
            allow 127.0.0.1;
            allow 172.16.0.0/12;
            deny all;
        }
    }
}